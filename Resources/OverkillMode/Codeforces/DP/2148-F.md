
greedy + smart brute force

```cpp
#include<bits/stdc++.h>
using namespace std;
 

void solve() {
  
    int n;
    cin>>n;
    vector<vector<int>> v(n);
    int maxLen = 0;

    for (int i=0; i<n; ++i) {
        int k;
        cin>>k;

        v[i].resize(k);
        maxLen = max(maxLen, k);

        for (int j=0; j<k; ++j) {
            cin>>v[i][j];
        }
    }

    /*

    we will start with lexicographically smallest prefix and we will go on
    appending lexicographically smaller suffixes from other larger arrays

    if we start with a lexicographically smallest it may happen a larger 
    length has better suffix as compare to a smaller suffix for a given 
    prefix
    so we need to build from larger suffix
    */

    // relevant[i] -> list of array indices with length >= i+1
    vector<vector<int>> relevant(maxLen+1);

    for (int i=0; i<n; ++i) {
        for (int j=0; j<(int)v[i].size(); ++j) {
            relevant[j].push_back(i);
        }
    }

    vector<int> rank(n, -1);
    vector<int> lexMin(maxLen, -1);

    for (int col = maxLen-1; col >= 0; --col) {
        vector<array<int, 3>> curr; // {val_at_col, rank_suffix, array_index}
        
        for (int idx : relevant[col]) {
            int valAtCol = v[idx][col];
            curr.push_back({valAtCol, rank[idx], idx});
        }

        // sorted by valAtCol, 
        // previousRank (for not selected shorter arrays, it will be -1)
        sort(begin(curr), end(curr));

        lexMin[col] = curr[0][2];

        // update ranks for next iteration  
        int currRank = 0;
        rank[curr[0][2]] = currRank;

         for (int k = 1; k < (int)curr.size(); ++k) {
            if (curr[k][0] != curr[k - 1][0] || curr[k][1] != curr[k - 1][1]) {
                ++currRank;
            }
            rank[curr[k][2]] = currRank;
        }

    }


    // print answer
    vector<int> ans;

    while((int)ans.size() < maxLen) {
        int prefixLen = (int)ans.size();
        int lexMinIndex = lexMin[prefixLen];
        
        vector<int> arr = v[lexMinIndex];
        
        for (int i=prefixLen; i<(int)arr.size(); ++i) {
            ans.push_back(arr[i]);
        }
    }

    for (auto &c : ans) {
        cout<<c<<" ";
    }

    cout<<"\n";
   
}   
 
 
signed main (void)
{
    #ifndef ONLINE_JUDGE
        freopen("./input.txt", "r", stdin);
        freopen("./output.txt", "w", stdout);
    #endif
    
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
 
    int ttc=1;
    cin>>ttc;
    for(int tc=1; tc<=ttc; ++tc){
         solve();
    }
    return 0;
} 
```

Any large length array can contribute to any index lower than or equal its length
so we need to keep including it and updating on it's rank accordingly