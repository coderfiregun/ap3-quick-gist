```cpp
#include<bits/stdc++.h>
using namespace std;

const long long MAX_VAL = 1000000000000000005;

void rotateAntiClockWise(vector<int> &v) {
    for (int i=2; i<(int)v.size(); ++i) {
        swap(v[i], v[i-1]);
    }
}

int getCost(int x, int y) {
    return abs(x-y);
}

int getCost(int x, int y, int z) {
    // if x, y, z are sorted
    // y-x + z-y = z-x

    return max(x, max(y, z)) - min(x, min(y, z));
}
 
void solve() {
   int n;
   cin>>n;

   vector<int> v(n+1);

   for (int i=1; i<=n; ++i) {
    cin>>v[i];
   }
   

   /* 
    we can form continous groups of size 2 and 3
    for any index i, it can be shown anyb group larger than of size 2 and 3 can be 
    broken into exact size of 2 and 3s in optimal solution

    dp[i] = min(dp[i-2] + group(i, i-1), dp[i-3] + group(i-2, i-1, i))

    we need to also handle the array being circular so it can end as
    rotation 0 : ...., n-2, n-1
    rotation 1 : ....., n-2, n-1, 1
    rotation 2 : ....., n-2, n-1, 1, 2

    rotation 3 : ....., n-2, n-1, 1, 2, 3    -> (...n-1, 1) and (2, 3) [same as rotation 1]
    rotation 4 : ....., n-2, n-1, 1, 2, 3, 4 -> (n-1, 1, 2) ans (3, 4) [Same as rotation 2]
   */

   long long ans = MAX_VAL;
   

   for (int cyc=0; cyc <= 2; cyc++) {
    vector<long long> dp(n+1);

    dp[0] = 0;
    dp[1] = MAX_VAL;

    for (int i=2; i<=n; ++i) {
        dp[i] = dp[i-2] + getCost(v[i], v[i-1]);
        if (i >= 3) {
            dp[i] = min(dp[i], dp[i-3] + getCost(v[i], v[i-1], v[i-2]));
        }
    }

    ans = min(ans, dp[n]);
    rotateAntiClockWise(v);
   }
   
   cout<<ans<<"\n";
   
}   
 
 
signed main (void)
{
    #ifndef ONLINE_JUDGE
        freopen("./input.txt", "r", stdin);
        freopen("./output.txt", "w", stdout);
    #endif
    
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
 
    int ttc=1;
    cin>>ttc;
    for(int tc=1; tc<=ttc; ++tc){
         solve();
    }
    return 0;
} 
```